1 buffer = n * automata state (n = 2 * int || 1 / 2 * int)
audio engine requests automata updates
graphics engine draw current auotmata state on screen, in case in changed
(automata refresh rate is independant from animation rate)

audio engine can tell automata: "i expect 2048 samples per update"

bufLen / rate = grainLength

automata:
  n audioGen
    owning n cells
      to compute a grain

grain uses an oscillator and a gain
how do we modulate pitch and gain ?

TODO: save CFG to remember patterns

BUG CHROME: buffer du scriptnode n'est pas vid√©, il faut le faire explicitement

/**
	 * Simplifies a path using Douglas-Peucker algorithm
	 * @param	points
	 * @param	epsilon
	 * @return
	 */
	static public function douglasPeuckerSimplification(points:Array<Point2D>, epsilon:Float):Array<Point2D>
	{
		Log.trace("points : " + points.length);
		
		var dmax:Float = 0.0;
		var d:Float = 0.0;
		var index:Int = 0;
		var result:Array<Point2D>;
		
		for (i in 1 ... points.length) {
			d = perpendicularDistance(points[i], lineEq(points[0], points[points.length - 1]));
			if (d > dmax) {
				index = i;
				dmax = d;
			}
		}
		
		if (dmax >= epsilon) {
			var recResults1:Array<Point2D> = douglasPeuckerSimplification(
				points.slice(0, index + 1), 
				epsilon);
			var recResults2:Array<Point2D> = douglasPeuckerSimplification(
				points.slice(index, points.length), 
				epsilon);
			
			recResults1.pop();
			result = recResults1.concat(recResults2);
		} else {
			result = [
				points[0],
				points[points.length - 1]
			];
		}
		
		return result;
	}
	
	//-- DISTANCE BETWEEN A POINT AND A LINE (DEFINED BY ITS EQUATION)
	static public inline function perpendicularDistance(pt:Point2D, line:LineEq):Float
	{
		return Math.abs(line.m * pt.x - pt.y + line.p) / Math.sqrt(line.m * line.m + 1);
	}
	
	/**
	 * returns line's eq as y = m * x + p
	 * @param	ptA
	 * @param	ptB
	 * @return
	 */
	static public inline function lineEq(ptA:Point2D, ptB:Point2D):LineEq
	{
		//-- y = m * x + p;
		var m:Float = (ptA.y - ptB.y) / (ptA.x - ptB.x);
		return {
			m : m,
			p : ptA.y - m * ptA.x
		}
	}
